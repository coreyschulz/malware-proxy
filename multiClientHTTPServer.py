################
## Corey Schulz
## CS 4480
## SP2018
## PA1.2 - Multi Client HTTP Proxy
##########################

from socket import *
from urllib.parse import *
import hashlib
import json
import requests
import time
import _thread

vtAPIKey = ""
alreadySent = False

def getHTTPContentsSimple(clientInput):
    connectPort = "80"  ## Default port unless otherwise specified.

    ######
    ## Parse string content to ensure three things for simple iteration..
    ###########

    requestParts = clientInput.split(" ")

    if len(requestParts) != 3:
        returner = "proxyERROR Improper request format. Bad request. Error: 400!?".encode()
        return returner

    requestParts[0] = requestParts[0].upper()  ## Ensures GET capitalized.

    if requestParts[0] != "GET":
        returner = "proxyERROR Not implemented. Error: 501!!".encode()
        return returner

    if not "http://" in requestParts[1]:
        returner = "proxyERROR Improper requet format. Bad request. Ensure 'http://' in request URL for this request!"

    requestParts[2] = requestParts[2].upper()  ## Sets HTTP/1.0 to upper.

    if requestParts[2] != "HTTP/1.0":
        returner = "proxyERROR Only HTTP/1.0 accepted. Please try again. Error: 401".encode()

    if ":" in requestParts[1][7:]:  ## If there's a port number, pull it out!
        portNumber = requestParts[1][7:].split(':')
        connectPort = portNumber[1]

    finalConnectPort = ""
    for x in range(0, len(connectPort)):
        if connectPort[x].isdigit():
            finalConnectPort += connectPort[x]

    print("Connection on port... " + finalConnectPort) ## HERE

    #######
    ## End Parse String Content!
    #############

    parsed = urlparse(requestParts[1])  ## Allows path and hostname to be pulled out easily.

    httpDoer = socket(AF_INET, SOCK_STREAM)
    try:
        httpDoer.connect((parsed.hostname, int(finalConnectPort)))  ## Tries to connect...
    except:
        returner = "proxyERROR Problem with URL parsing. Please enter a valid one. Thanks! Error: 401\nYou connected on port: " + str(finalConnectPort)
        returner = returner.encode()

        return returner

    extension = parsed[2]  ## gets extension for the entered URL.
    if extension == '':
        extension = "/"  ## If no extension, then it's just a slash.

    sender = "GET " + extension + " HTTP/1.0\r\nHost: " + parsed.hostname + "\r\nConnection: close\r\n\r\n"
    httpDoer.send(sender.encode())

    returner = recvall(httpDoer)

    httpDoer.close()

    return returner


def getHTTPContentsComplex(clientInputs):
    InitRequestParts = clientInputs[1].split(' ')
    connectionPort = "80"

    ######
    ## Parse string content!
    ###########

    if len(InitRequestParts) != 3:
        returner = "proxyERROR Improper request format. Bad Request. Error: 400".encode()
        return returner

    InitRequestParts[0] = InitRequestParts[0].upper()
    if InitRequestParts[0] != "GET":
        returner = "proxyERROR Not implemented. Error: 500".encode()
        return returner

    if not '/' in InitRequestParts[1]:  ## Needs a slash for the path...
        returner = "proxyERROR Improper request format. Bad Request. Error: 400".encode()
        return returner

    InitRequestParts[2] = InitRequestParts[2].upper()
    if InitRequestParts[2] != "HTTP/1.0":
        returner = "proxyERROR Only HTTP/1.0 Implemented. Error: 401".encode()
        return returner

    if not "Host: " in clientInputs[2]:
        return "proxyERROR Error! Host not specified! Error: 405".encode()

    hostname = clientInputs[2].split(' ')

    if len(hostname) != 2:
        return "proxyERROR Error with host specification. Error: 405".encode()

    if ':' in hostname[1]:
        porter = hostname[1].split(':')
        connectionPort = porter[1]  ## Porter = [hostname, port]
        temphostname = porter[0]
    else:
        temphostname = hostname[1]

    ######
    ## End parse string content!
    ###########

    finalConnectionPort = ""

    httpDoer = socket(AF_INET, SOCK_STREAM)
    try:
        httpDoer.connect((temphostname, int(connectionPort)))  ## 80 is just DEFAULT port.
    except:
        returner = "proxyERROR Problem with URL parsing. Please enter a valid one. Thanks! Error: 401".encode()
        return returner

    ## sender = "GET " + extension + " HTTP/1.0\r\nHost: " + parsed.hostname + "\r\nConnection: close\r\n\r\n"

    sender = "GET " + InitRequestParts[1] + " HTTP/1.0\r\n"

    for x in range(2, len(clientInputs)):
        requestModifiers = clientInputs[2].split(' ')
        if len(requestModifiers) != 2:
            return "proxyERROR Error! Modifier length not 2. Error: 406"
        if not ':' in requestModifiers[0]:
            return "proxyERROR Error! Bad modifier syntax! Error: 407"
        sender += requestModifiers[0] + " " + requestModifiers[1] + "\r\n"

    sender += "Connection: close\r\n\r\n"

    httpDoer.send(sender.encode())

    returner = recvall(httpDoer)

    httpDoer.close()


    return returner


def curlRequestSender(helperInput):
    #if "HTTP/1.0" not in helperInput:
        #returner = "proxyERROR Only HTTP/1.0 valid! Please try again. Error: 401"
        #return returner.encode()

    if not "GET" in helperInput:
        returner = "proxyERROR Error! Only GET implemented. Error: 502"
        return returner.encode()

    connectionPort = "80"
    overallURL = find_between(helperInput, "GET ", " HTTP")
    parsed = urlparse(overallURL)
    temphostname = find_between(helperInput, "Host: ", "\r\n")

    extension = parsed[2]  ## gets extension for the entered URL.
    if extension == '':
        extension = "/"  ## If no extension, then it's just a slash.

    if ":" in temphostname:
        portSplitter = temphostname.split(":")
        connectionPort = portSplitter[1]
        temphostname = portSplitter[0]

    sender = "GET " + extension + " HTTP/1.0\r\nHost: " + temphostname + "\r\nConnection: close\r\n\r\n"

    httpDoer = socket(AF_INET, SOCK_STREAM)
    try:
        httpDoer.connect((temphostname, int(connectionPort)))  ## 80 is just DEFAULT port.
    except:
        returner = "proxyERROR Problem with URL parsing. Please enter a valid one. Thanks! Error: 401".encode()
        return returner

    httpDoer.send(sender.encode())
    returner = recvall(httpDoer)
    httpDoer.close()

    return returner


## Function to receive all data from a website's GET response.
## Modified version of John Neilsen's recvall function to work with
## byte arrays. Used with permission.
def recvall(the_socket, timeout=''):
    # setup to use non-blocking sockets
    # if no data arrives it assumes transaction is done
    # recv() returns a string
    the_socket.setblocking(0)
    total_data = []
    data = ''
    begin = time.time()
    if not timeout:
        timeout = 1
    while 1:
        # if you got some data, then break after wait sec
        if total_data and time.time() - begin > timeout:
            break
        # if you got no data at all, wait a little longer
        elif time.time() - begin > timeout * 2:
            break
        wait = 0
        try:
            data = the_socket.recv(4096)
            if data:
                total_data.append(data)
                begin = time.time()
                data = ''
                wait = 0
            else:
                time.sleep(0.1)
        except:
            pass
        # When a recv returns 0 bytes, other side has closed
    result = b''.join(total_data)  ## Forces total data into bytes array.
    return result

## Helper method to find between strings.
## Used in prebuilt send requests like curl.
## Used to pull out the host to connect the socket to.
def find_between( s, first, last ):
    try:
        start = s.index( first ) + len( first )
        end = s.index( last, start )
        return s[start:end]
    except ValueError:
        return ""




## This function is run on a new thread every time
##  a new host connects to the server...
def getNewClient(connectionSocket, addr):
    inputsFromClient = []
    inputsFromClient.append("INIT")

    threadDone = False
    inputLoop = True;

    while threadDone == False:

        getinputs = True


        while getinputs:  ## As long as a blank line hasn't been entered...
            clientInput = connectionSocket.recv(65536).decode("unicode_escape")
            clientInput = clientInput.strip()
            if clientInput[-5:] == "Alive":
                getinputs = False
                #prehash = prebuiltSend(clientInput)
                #hash = getMD5(prehash)
                #if isThereMalware(hash) == False:
                 #   connectionSocket.send(prebuiltSend(clientInput))
                #lse:
                    #sender = httpInfo.split(b'\r\n\r\n')
                    #connectionSocket.send(sender[0] + b'\r\n\r\n' + b'<!DOCTYPE html>\r\n<html>\r\n<body>\r\n\r\n<h1>Content blocked; suspected of malware.</h1>\r\n\r\n</body>\r\n</html>\r\n')
                #lreadySent = True
            inputsFromClient.append(clientInput)
            if inputsFromClient[len(inputsFromClient) - 1] == '':
                getinputs = False

        if inputsFromClient[1][-5:] == "Alive":
            content = curlRequestSender(inputsFromClient[1])
            overarchingSender(connectionSocket, content)

        else:

            inputsFromClient = inputsFromClient[:-1]  ## Removes last item from list...

            if len(inputsFromClient) == 2:
                httpInfo = getHTTPContentsSimple(inputsFromClient[1])  ## w00t!

            elif len(inputsFromClient) == 1:  ## Idiots.
                httpInfo = "Error! You didn't input anything!!"

            else:  ## Getting complex, are we!?
                httpInfo = getHTTPContentsComplex(inputsFromClient)

            overarchingSender(connectionSocket, httpInfo)

        threadDone = True
        connectionSocket.close()  ##... And clean up.
        inputsFromClient = []
        inputsFromClient.append('INIT')
        print("FINISHED THAT ONE.")

def overarchingSender(sendSocket, httpInfo):
    if b"proxyERROR" in httpInfo: ## If there's an error...
        sendSocket.send(httpInfo)

    else:
        hasher = getMD5(httpInfo)
        try:
            if isThereMalware(hasher, vtAPIKey) == False:
                sendSocket.send(httpInfo)
            else:
                sender = httpInfo.split(b'\r\n\r\n')
                sendSocket.send(sender[0] + b'\r\n\r\n' + b'<!DOCTYPE html>\r\n<html>\r\n<body>\r\n\r\n<h1>Content blocked; suspected of malware.</h1>\r\n\r\n</body>\r\n</html>\r\n')
        except:
            print("Error sending data!! Closing socket to client. Please try again.")

    return


def filterActualContent(dataInput):
    hachi = dataInput.split(b'\r\n\r\n')
    return hachi[1]

def getMD5(dataInput):
    dataInput = filterActualContent(dataInput)
    hashObj = hashlib.md5(dataInput)
    returner = hashObj.hexdigest()
    return returner

def isThereMalware(md5Hash, apiKey):
    params = {'apikey': apiKey, 'resource': md5Hash}
    headers = {
        "Accept-Encoding": "gzip, deflate",
        "User-Agent": "gzip,  Virus Buster Assuming Prior Scan(TM)"
    }
    response = requests.get('https://www.virustotal.com/vtapi/v2/file/report',
                            params=params, headers=headers)
    json_response = response.json()

    if json_response["response_code"] == 0:
        return False

    if json_response["positives"] >= 1:
        return True

    return False




def main():
    proxyPort = input("Which port would you like this proxy to function on...? ")
    global vtAPIKey
    vtAPIKey = input("...And what's your VirusTotal API Key? ")
    vtAPIKey = vtAPIKey.strip()
    proxySocket = socket(AF_INET, SOCK_STREAM)
    try:
        proxySocket.bind(('', int(proxyPort)))
    except:
        print("You did not enter a valid port number. Please try again.")
        return
    proxySocket.listen(1)

    print("Ready to accept incoming connections~~!")
    print("Awaiting clients!")

    while True:
        connectionSocket, addr = proxySocket.accept()
        _thread.start_new_thread(getNewClient, (connectionSocket, addr))
        ## Start a new thread...!


main()


## get file using SIMPLEHTTPSERVER. Parse content out of HTTP GET response, then get MD5 checksum.
## Send checksum to VirusTotal, parse response.
    ## If response == virus
        ## Block content and replace with simple HTML page.
    ## If response == noVirus
        ## Allow content through && send file to host. (HTTP GET Response format...?)
